# 그리디 - 백준 1202

> [문제 링크](https://www.acmicpc.net/problem/1202)  
> [풀이](https://github.com/minSsan/algorithm/blob/main/baekjoon/%EA%B7%B8%EB%A6%AC%EB%94%94/1202.cpp)

[예전 문제풀이 과정](https://github.com/minSsan/algorithm/blob/main/%EB%85%B8%ED%8A%B8/%5B%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8%5D%20%EA%B7%B8%EB%A6%AC%EB%94%94%20-%20%EB%B0%B1%EC%A4%80%201202.md)을 다시 살펴봤는데, 지금 다시 보니까 전제를 너무 복잡하게 설정해서 풀었던 것 같다. _(당시에도 실제 문제 풀이 과정에서 이렇게 명제를 증명해서 할 수 있을지 의문이 들었는데 ..)_

---

## 문제 이해하기

**주어진 가방들**을 사용하여 **최대 값어치**를 얻을 수 있도록 보석을 담아야 한다. _단, 하나의 가방에는 하나의 보석만 담을 수 있다._

### 0-1 냅색 문제와 비교하기

#### 0-1 냅색 문제

`0-1 냅색 문제`의 경우, 하나의 가방에 여러 개의 보석을 담기 때문에, **현재 가방에 넣을 수 있는 최대 가치 합**은 **앞서 더 적은 용량의 가방에서의 최대 가치 합**에 따라서 결정할 수 있다.

- 즉, 앞선 결과 값들을 토대로 현재의 결과 값을 구할 수 있기 때문에 `DP`로 해결 가능하다.

#### 백준 1202번

하지만 이번 문제는 하나의 가방에서 이뤄지는 것이 아닌, **독립적인 가방 여러 개**에 **각각 어떤 보석을 넣을 것인지**에 대한 문제이다.

- `0-1 냅색 문제`에서는 앞서 `참`이었던 최선의 결과가 `거짓`으로 변하지 않음
- 하지만, 이 문제의 경우에는 어떤 가방, 어떤 보석까지 고려할 것인지에 따라서 최선의 선택이 변경될 수 있다.
  - ex) `2kg 가방`과 `{1kg, 65$}`, `{2kg, 99$}` 보석 두 개가 존재할 때,
    - **1kg 보석만 고려하는 경우** - 가방에 1kg짜리 보석을 넣는 것이 최선의 결과
    - **2kg 보석까지 고려하는 경우** - 가방에 2kg짜리 보석을 넣는 것이 최선의 결과 👉🏻 **앞선 결과가 `거짓`으로 바뀜** _(dp 점화식 불가능)_

---

## 문제 해결하기

**기본 전제**

- 보석의 값어치 합이 최대가 되기 위해서는, 비어있는 가방 없이 `모든 가방에 가능한 보석을 넣어야` 한다.

이러한 기본 전제를 바탕으로, `어떤 가방에 어떤 방식으로 보석을 담아야 하는지`에 대한 세부 전제를 설정해야 한다.

### 세부 전제 설정하기

- `각각의 가방에 어떤 보석을 담을 것인지`는 **각 가방에 담을 수 있는 보석들**에 한해서 비교해야 한다.
  - 각 가방에 넣을 수 있는 보석들 중에서 **가장 가치가 높은 것**을 선택하는 것이 이득일 것이다.
- **가벼운 보석**은 자신의 무게 이상의 가방이라면 어디에든 넣을 수 있다.
  - **가장 가벼운 가방부터 시작**해서, 각 가방에 어떤 보석을 넣을지 결정한다.
  - 여기서 `선택되지 않은 보석들`은 **뒤에 나오는 가방에도 충분히 넣을 수 있다.**

👉🏻 가벼운 가방부터 차례대로 살펴보고, **각 가방에 넣을 수 있는 보석들 중**에서 `가장 값어치가 큰 것`을 선택한다.  
👉🏻 이때 선택되지 않은 보석들은 뒤에 오는 가방에도 충분히 넣을 수 있으므로, 후보로 유지한다. _(즉, 무게가 가볍더라도 값어치가 충분히 크다면, 더 무거운 가방에서 선택될 수 있다.)_

## 코드 작성하기

1. 무게를 기준으로 보석을 확인하기 위해 `min heap`을 정의한다.

   ```cpp
   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // {무게, 가격}

   for (int i = 0; i < n; ++i) {
       int w, v;
       cin >> w >> v;
       pq.push({w, v});
   }
   ```

2. 무게를 기준으로 가방을 확인하기 위해 `오름차순 정렬`한다.

   ```cpp
   int bags[k];
   for (int i = 0; i < k; ++i) {
       cin >> bags[i];
   }

   sort(bags, bags+k);
   ```

3. **현재 가방에 넣을 수 있는 보석들의 값어치**를 저장하기 위해 `max heap`을 정의한다.

   - 무게 조건이 성립하는 보석의 값어치가 **새로 추가될 때마다**, 최대 값어치가 올바르게 **정렬되어야 함** 👉🏻 `priority queue` _(= max heap)_ 필요

   ```cpp
   priority_queue<int> coord;
   ```

4. 각 가방에 어떤 보석을 넣을지 결정하기 위해, **가장 가벼운 가방부터 순회**한다.

   ```cpp
   long long result = 0; // 보석 최대 개수 * 보석 최대 값어치 > int 자료형
   for (int i = 0; i < k; ++i) {
       int weight = bags[i];
   }
   ```

5. 현재 가방에 넣을 수 있는 보석 중에서 값어치가 가장 큰 것을 선택한다.

   ```cpp
   for (int i = 0; i < k; ++i) {
       int weight = bags[i];

       // 현재 가방에 넣을 수 있는 보석을 후보에 모두 추가하기
       while (!pq.empty() && pq.top().first <= weight) {
           coord.push(pq.top().second);
           pq.pop();
       }

       // 넣을 수 있는 보석 중 가장 비싼 보석 넣기
       result += coord.top();
       coord.pop();
   }
   ```

6. 예외 처리(1) - 더이상 남은 보석이 없는 경우

   - 후보에 존재하는 보석들을 값어치가 높은 순으로 남은 가방에 넣고 종료

   ```cpp
   for (int i = 0; i < k; ++i) {
       int weight = bags[i];

       // 남은 보석이 없는 경우 -> coord에 남은 보석을 남은 가방에 모두 넣기
       if (pq.empty()) {
           for (int j = 0; j < k-i; ++j) {
               if (!coord.empty()) {
                   result += coord.top();
                   coord.pop();
               }
           }
           break;
       }

       // 현재 가방에 넣을 수 있는 보석을 후보에 모두 추가하기
       while (!pq.empty() && pq.top().first <= weight) {
           // ...
       }

       // 넣을 수 있는 보석 중 가장 비싼 보석 넣기
       result += coord.top();
       coord.pop();
   }
   ```

7. 예외 처리(2) - 추가할 후보가 존재하지 않는 경우 _(= 남은 보석들의 무게가 모두 현재 가방보다 무거운 경우)_

   - 현재까지의 후보들 중에서 가장 무거운 보석 넣기

   ```cpp
   for (int i = 0; i < k; ++i) {
       int weight = bags[i];

       // 남은 보석이 없는 경우 -> coord에 남은 보석을 남은 가방에 모두 넣기
       if (pq.empty()) {
           // ...
       }

       // 현재 보석의 무게가 가방 무게를 초과하는 경우 -> 다음 가방
       if (pq.top().first > weight) {
           // 앞에서 넣지 않은 보석이 있는 경우 -> 현재 가방에 추가
           if (!coord.empty()) {
               result += coord.top();
               coord.pop();
           }
           continue;
       }

       // 현재 가방에 넣을 수 있는 보석을 후보에 모두 추가하기
       while (!pq.empty() && pq.top().first <= weight) {
           // ...
       }

       // 넣을 수 있는 보석 중 가장 비싼 보석 넣기
       result += coord.top();
       coord.pop();
   }
   ```

## 정리

매우 가벼운 보석은 어느 가방에도 넣을 수 있다는 사실을 기반으로, 명확하게 전제를 설정하는 것이 중요했던 것 같다.

그리고 그리디 문제에서는 `예외처리에 특히 주의해야 함`을 느낀다.
