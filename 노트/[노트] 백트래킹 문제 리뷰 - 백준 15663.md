# 문제 리뷰

> [문제 링크](https://www.acmicpc.net/problem/15663)  
> [답안 코드](https://github.com/minSsan/algorithm/blob/main/baekjoon/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/15663-2.cpp)

```markdown
재귀 함수는 `하나의 동일한 부모 가지`에서부터 `여러 개의 자식 가지`로 뻗어 나가는 과정임을 이해한다.
```

## 문제 해석

> 이 문제의 핵심은 `중복되는 수열`을 제외하는 것이다.

백트래킹에서 수열이 중복되는 경우는, **추가하려는 번호**가 **이미 `동일한 나뭇가지`에서 뻗어나온 경우**이다.

```
주어진 숫자
[ 1, 2, 3(1), 3(2), 4, 9, 9 ]

BASE: 1 -> 2
- 다음 나뭇가지가 3인 경우가 두 가지 존재한다.
    👉🏻 3(2)을 추가하려고 시도할 때 이를 막아야 한다.
```

- 백트래킹 재귀함수 동작 흐름에 따라서, `1 -> 2`를 거친 후에 호출된 재귀함수 내부에서 중복되는 가지를 검사해야 한다.
  - 가지가 `3(1)`로 뻗어나갈 때 이를 기록해두면,
  - 가지가 `3(2)`로 뻗어나갈 때 값이 중복됨을 알 수 있다. _(= 동일한 부모 가지(`1->2`)에서, 이미 방문한 자식 가지(`3(1`))로 뻗어나가려는 것을 알 수 있다.)_
- 따라서 백트래킹 재귀함수 내부에 `가장 최근 생성된 자식 가지`를 기록해두고, **다음에 방문할 자식 가지**가 이 값과 동일한지 확인하면 된다.

## 오답 코드

```cpp
vector<vector<int>> results;

void dfs() {
    if (v.size() == m) {
        results.push_back(v);
        return ;
    }

    int last = -1;
    for (int i = 0; i < n; ++i) {
        if (!visited[i] && (results.empty() || nums[i] != results.back()[v.size()])) {
            last = nums[i];
            visited[i] = true;
            v.push_back(nums[i]);
            dfs();
            visited[i] = false;
            v.pop_back();
        }
    }
}
```

👉🏻 이 코드의 핵심은 `nums[i] != results.back()[v.size()]` 이 조건을 확인하는 부분이다.

- 해당 조건의 의미는 다음과 같다.

  ```
  현재 추가하려는 값이, 직전에 생성된 결과 가지와 동일한 위치에 존재하지 않는 경우
  ```

  하지만 이 조건은 논리적으로 오류가 존재한다.  
  ⭐️⭐️⭐️ `가장 최근에 추가된 가지`가 `현재 가지`와 **동일한 부모를 갖는다**는 보장이 없기 때문이다.

  - `4 - 3 - 3`_(<= `4 - 3`)_ 과 `3 - 4 - 3`_(<= `3 - 4`)_ 은 부모 가지가 서로 다르지만, 위의 조건문에 걸리면서 `4 - 3 - 3`을 중복 가지로 인식한다.

## 정답 코드

```cpp
void dfs() {
    // 동일한 가지
    if (v.size() == m) {
        for (int num : v) {
            cout << num << ' ';
        }
        cout << '\n';
        return ;
    }

    int last = -1;
    for (int i = 0; i < n; ++i) {
        if (!visited[i] && nums[i] != last) {
            last = nums[i];
            visited[i] = true;
            v.push_back(nums[i]);
            dfs();
            visited[i] = false;
            v.pop_back();
        }
    }
}
```

따라서, `부모 가지가 동일하다는 것이 보장된 상태`_(= 재귀함수 내부)_ 에서 **자식 가지의 중복 여부**를 검사해야 문제에서 요구하는 중복 조건을 정확하게 확인할 수 있다.
