# 문제 리뷰

> [문제 링크](https://www.acmicpc.net/problem/2240)  
> [답안 코드 1](https://github.com/minSsan/algorithm/blob/main/baekjoon/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95/2240.cpp)  
> [답안 코드 2](https://github.com/minSsan/algorithm/blob/main/baekjoon/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95/2579-2.cpp)

## 문제 풀이 과정

- 문제를 읽어보면 '그리디인가?' 싶다가도, 결국 `가능한 모든 경우의 수를 확인` 해야 답을 얻을 수 있음을 알 수 있다.
- 처음 문제 풀이를 시도했을 때는 풀이 방식이 잘 떠오르지 않아서, [백준 2156번 문제](https://www.acmicpc.net/problem/2156)를 먼저 풀어본 후에 다시 시도했다.

- 두 문제 모두 **_완전탐색을 진행하기에는 연산량이 과도하게 증가_** 하고, **_최적해를 보장하는 식도 존재하지 않는다._**
  - 👉🏻 이러한 경우 **메모이제이션**, `DP`를 활용할 수 있다.

### 2156번

> `2156번 문제`의 경우, **연속으로 마실 수 있는 잔의 개수**가 제한되어 있기 때문에, 이 정보를 같이 기록해야 한다.  
> 따라서 다음과 같은 dp 배열을 생성하여 문제를 해결했다.

```
dp[i][n] : 와인을 연속으로 n번, i잔 만큼 마셨을 때, 마실 수 있는 포도주의 최대 양
```

### 2240번

> `2240번 문제`의 경우, **시간이 몇 초 지났는지**와 **자두의 현재 위치**를 기록해야 하고, **이동 가능한 횟수**가 제한되어 있기 때문에, 세 가지 정보를 같이 기록해야 한다.  
> 따라서 다음과 같은 dp 배열을 생성하여 문제를 해결했다.

```
dp[t][cnt][tree] : t초 시점에, 자두가 cnt번 이동하여, tree번 나무 밑에 위치한 경우, 해당 시점까지 얻을 수 있는 자두의 최대 개수
```

단, 이 문제에서는 `자두의 처음 위치는 1번 나무 아래이다.` 라는 조건 때문에, **t초 시점에, 자두가 cnt번 이동해서 tree번 나무에 위치할 수 없는 경우**가 존재한다.

- 자두가 1번 나무에서 출발했을 때, 3초가 지난 시점까지 총 1번 이동해서 1번 나무 아래에 위치하는 경우는 존재하지 않는다. (= `dp[3][1][1]`)

즉, 경우의 수가 존재하지 않는 케이스를 별도로 구별해야 하므로 초기 값을 **-1**로 설정했다.  
그리고 **_존재하지 않는 케이스에 접근하는 과정_** 은 생략하도록 했다.

```cpp
if (dp[i][cnt][cur] == -1) continue;
```

## 정리

```
최선의 선택이 최적해를 보장(= 그리디)하지 않으며, 모든 경우의 수를 따져야 하는 완전탐색 문제라고 판단되었을 경우

👉🏻 메모이제이션, DP를 생각해볼 수 있다.
```

```
⭐️ DP 문제 유의점

접근 순서가 보장되지 않을 경우를 대비하여, 현재 저장된 값과 갱신할 값을 비교하고 더 큰 값을 선택해야 한다.
```
