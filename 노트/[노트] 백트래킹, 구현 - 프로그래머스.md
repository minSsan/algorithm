## 백트래킹(or DFS), 구현

[프로그래머스 문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/150368)

- `순열`을 구하기 위해 백트래킹을 활용할 수 있다. 이때, 중복순열의 경우 중복된 숫자를 허용하기 때문에 단순 DFS로도 해결할 수 있다.

### 정리 노트

문제를 읽고 처음에는 `브루트포스` 문제로 인식했다. 일단 문제를 읽어보면 수학적인 계산으로 최대 목표를 구하는 것은 아니라고 판단했고, 결국 **모든 경우의 수를 다 따진 다음 그 중에서 최대 목표를 갖는 값을 리턴해야 한다**고 생각했기 때문이다. 특히 이모티콘의 길이(<= 7) 제한과 유저 수(<= 100) 제한이 매우 작은 숫자이기 때문에 `브루트포스` 문제로 접근했다.

그렇다면 이 문제에서 완전탐색의 대상이 무엇인지 알아야 한다. 이 문제에서 각 이모티콘에는 `10%, 20%, 30%, 40% - 4개의 할인율` 중 하나의 값을 가진다. 즉, **주어진 이모티콘들에 각각 몇 퍼센트의 할인율이 적용되었는지에 대한 조합**을 모두 구해야 한다. (= `중복순열`)

- 예를들어 A, B, C 세 개의 이모티콘이 주어진 경우 (10, 10, 10), (10, 10, 20), (10, 10, 30), (10, 10, 40), (10, 20, 10), ... 와 같이 가능한 모든 조합을 구해야 하는 것이다.

따라서 중첩 for문을 이용하여, 각각의 조합에 대해 이룰 수 있는 결과치를 계산하여 이를 저장해두고, 마지막에 이를 역순 정렬을 하도록 설계했다.  
하지만 다시 생각해보니 중첩 for문을 사용하려면 for문의 수가 고정되어야 하는데, `중첩되는 for문의 수`는 결국 `주어진 이모티콘의 개수`와 일치해야 하므로 해당 방식은 사용할 수 없었다.

그러다가 문득 이전에 백트래킹+DFS로 **수열의 조합을 모두 구하는 문제**를 풀던 기억이 떠올랐고, 백트래킹(DFS)으로 다시 접근하여 문제를 해결할 수 있었다.
