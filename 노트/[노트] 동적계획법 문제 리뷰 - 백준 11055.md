# 문제 리뷰

> [문제 링크](https://www.acmicpc.net/problem/11055)  
> [답안 코드](https://github.com/minSsan/algorithm/blob/main/baekjoon/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95/11055.cpp)

## 문제 풀이 과정

- 문제에서 요구하는 수열의 최대 누적 합을 구하기 위해서는, **각 원소를 포함하는 수열의 원소 합**을 구하고, **_그 중 가장 큰 값_** 을 출력한다.

- 여기서 `i번째 원소 값`을 포함하는 수열 중, 합이 최대인 것을 구하기 위해서는 `i번째 원소보다 작은 숫자로 구성된 수열`중 합이 최대인 것을 찾고, 그 값에 i번째 원소 값을 더하면 된다.

```
👉🏻 결국, 현재 원소에 대한 최대 부분수열 합은 현재 원소보다 앞에 위치한 수열에 의해 결정된다.
따라서, 각 원소에 대해서 해당 원소를 포함하는 부분 수열의 최대 합을 기록해야 한다.
```

## 시간복잡도

주어지는 수열의 전체 길이 n은 1,000 이하이므로, `n^2`의 시간복잡도까지 커버 가능하다.

## 핵심 코드

```cpp
// ...
for (int i = 0; i < n; ++i) {
    // 현재 원소보다 앞에 위치한 부분 수열 탐색
    for (int j = 0; j < i; ++j) {
        // (1) j번째 원소보다 이전 원소로 끝나는 "증가하는 부분수열"에 현재 값을 추가하는 것
        // vs
        // (2) j번째 원소로 끝나는 "증가하는 부분수열"에 현재 값을 추가하는 것
        if (num[i] > num[j]) {
            dp[i] = max({dp[i], num[i] + dp[j]});
        }
    }
    // 현재의 수열 원소 합이 가장 큰지 비교 후 갱신
    if (dp[i] > max_sum) max_sum = dp[i];
}
// ...
```
