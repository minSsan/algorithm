## 문제 정보

> 삼성 SW 역량 테스트 - 2020년 하반기 오전 1번  
> [백준 20055번](https://www.acmicpc.net/problem/20055)
> 시뮬레이션, 구현

## 실수했던 부분

#### `시간복잡도` 고려하지 않고 문제풀이

- 시간복잡도를 고려하지 않았기 때문에, _"로봇을 **'올리는 위치'** 와 **'내리는 위치'** 가 정해져 있다."_ 는 문제 조건을 활용하지 못함
  - 이 조건을 이용하면, `로봇 이동 순서`를 지키기 위한 벨트 탐색 과정이 불필요해짐 _(`O(N)`으로 로봇을 이동시킬 수 있음)_

#### 1️⃣ 첫 번째 풀이 로직 _(O(N^2))_

```
1. 모든 로봇 번호(MAX: 200,000) 탐색
2. 그 중, 벨트 위에 있는 로봇들을 모두 한 칸씩 이동
3. '내리는 위치'에 있는 로봇 하차
```

#### 2️⃣ 두 번째 풀이 로직 _(O(N))_

> ### 💡 풀이 아이디어
>
> 올리는 위치는 `0`, 내리는 위치는 `N-1`인 것을 활용
>
> - 로봇은 항상 컨베이어 벨트의 윗 칸에만 존재
> - **윗 칸**에서 로봇은 항상 `우측`으로 이동
> - 👉🏻 즉, `N-2`번 칸부터 `0`번 칸까지의 순서대로 탐색하면 _"먼저 올라간 순서대로 이동하는 것"_ 을 보장할 수 있음

```
1. 컨베이어의 N-2번 ~ 0번 위치를 순서대로 탐색
2. 그 중, 로봇이 있는 벨트에 대해서만 로봇의 위치를 한 칸 이동
3. '내리는 위치'에 있는 로봇 하차
```

### ✍🏻 문제점 회고

> 시간 복잡도를 항상 고려한다. _(문제풀이 과정 정형화할 필요성)_

## 비슷한 유형 문제에서 주의해야 할 부분

- `시간복잡도` 계산을 마친 후에 로직을 설계한다.  
  특히 이번 문제에서 시간복잡도를 고려한 상태에서 설계하니, **문제에 있는 조건**을 활용할 수 있었음.

## 전체 리뷰

- 문제풀이 순서를 다음과 같이 정한다.

```
1. 문제 읽으면서 주요 조건 및 주의점 필기
2. 🌟 시간 복잡도 계산 (O(N), O(2^N), O(N^2), O(NlogN), O(logN))
3. 🌟 로직 설계
4. 코드 작성 및 복잡도 계산
4. 🌟 edge case에 대해서 직접 테스트 코드 돌려보기
5. 모든 테스트 케이스가 통과하면 제출
```
