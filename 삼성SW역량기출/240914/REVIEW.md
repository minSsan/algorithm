## 문제 정보

> 삼성 SW 역량 테스트 - 2020년 하반기 오전 1번  
> [백준 20057번](https://www.acmicpc.net/problem/20057)
> 시뮬레이션, 구현

## 실수했던 부분

- 코드 간결성 부족으로 실수 증가

  - [첫 번째 코드](<https://github.com/minSsan/algorithm/blob/main/%EC%82%BC%EC%84%B1SW%EC%97%AD%EB%9F%89%EA%B8%B0%EC%B6%9C/240914/%5B24.09.14%5D2020%ED%95%98%EB%B0%98%EA%B8%B0(%EC%98%A4%ED%9B%841%EB%B2%88).cpp>) 의 경우, 각 방향에 대해 모두 분기문으로 처리하여 코드가 매우 길어지고, 그만큼 실수가 잦았음.
  - 이를 개선하기 위해 [두 번째 코드](<https://github.com/minSsan/algorithm/blob/main/%EC%82%BC%EC%84%B1SW%EC%97%AD%EB%9F%89%EA%B8%B0%EC%B6%9C/240914/%5B24.09.14%5D2020%ED%95%98%EB%B0%98%EA%B8%B0(%EC%98%A4%ED%9B%841%EB%B2%88)-2.cpp>)를 다시 작성하였음.

- 문제 이해 부족

  - `"α로 이동하는 모래의 양은 비율이 적혀있는 칸으로 이동하지 않은 남은 모래의 양과 같다."` 독해 실수

    👉🏻 α로 이동하는 모래의 양 = y의 모래 양 - (비율이 적혀있는 칸으로 이동한 모래 양 + **격자 밖으로 나간 모래 양**)

> ### ✍🏻 문제점 회고
>
> 가장 큰 문제점은 **"코드의 간결성 부족"** 이다.  
> 특히 배열을 탐색하는 과정에서 *각 방향을 모두 분기*하여 반복되는 코드가 증가했음. 이로 인해 실수할 가능성도 매우 높아짐.

## 비슷한 유형 문제에서 주의해야 할 부분

### 복잡한 이차원 배열 탐색

> 문제에 주어진 `탐색 규칙`을 토대로 *dr 배열*과 *dc 배열*을 구상한다.

- 👉🏻 **이차원 배열을 탐색**하는 경우, 탐색 방향을 `dr 배열` 및 `dc 배열`로 정의하면 더 간결한 코드를 작성할 수 있다.

- 👉🏻 이 문제에서는 `네 가지의 이동 방향`에 따라서 _dr 값과 dc 값이 달라졌다._  
  이 경우에는 dr, dc를 각각 **이차원 배열로 정의**하면 _[각 방향에 대한 dr 값과 dc 값을 따로 정의](<https://github.com/minSsan/algorithm/blob/main/%EC%82%BC%EC%84%B1SW%EC%97%AD%EB%9F%89%EA%B8%B0%EC%B6%9C/240914/%5B24.09.14%5D2020%ED%95%98%EB%B0%98%EA%B8%B0(%EC%98%A4%ED%9B%841%EB%B2%88)-2.cpp#L16-L27>)_ 할 수 있다.

## 전체 리뷰

1. ⚠️ 문제 독해 주의

   - 명확한 설명이 없더라도 스스로 유추한다.
     - 특히, 이번 문제 설명의 _"α로 이동하는 모래의 양은 비율이 적혀있는 칸으로 이동하지 않은 `남은 모래의 양`과 같다."_ 에서  
       `"남은 모래의 양"`은 문제에서 명확히 설명하지 않았더라도 **스스로 유추**할 수 있어야 한다. _(남은 모래 = **격자 밖으로 나가지 않고** 남은 모래)_

2. 이차원 배열 탐색 전략
   - 무조건 분기로 모든 경우를 나누는 것보다 최대한 `dr`, `dc` 배열을 활용하는 방식을 택한다.
