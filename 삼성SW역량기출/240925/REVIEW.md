## 문제 정보

> 삼성 SW 역량 테스트 - 2020년 상반기 오후 2번  
> [백준 19238번](https://www.acmicpc.net/problem/19238)  
> 시뮬레이션, 구현, 그래프 탐색

## 구현 과정

- 문제 필기 + 로직 설계 (약 20분)
- 코드 작성 (약 50분)
- 문제점 해결 (약 1시간)

## 문제가 된 부분

- **[잘못된 코드]** 아래는 승객을 마주했을 때, **해당 승객과 동일한 거리에 있는 승객들**을 모두 후보 벡터에 추가하고자 작성한 코드이다.

  ```cpp
  if (road[row][col] >= 2) {
      while (!q.empty()) {
          if (road[q.front().first][q.front().second] >= 2) {
              coord.push_back({road[q.front().first][q.front().second], q.front().first, q.front().second});
          }
          q.pop();
      }
      // ... 생략 ...
  }
  ```

  - ⭐️ `BFS while문`을 실행하는 한 주기마다, _큐에는 동일한 거리의 위치만 존재한다_ 고 생각했는데 그게 아니었음  
    👉🏻 **맨 처음 위치**를 방문했을 때는 이를 만족하지만, 그 이후부터는 만족하지 않음.
    - _(BFS 동작 흐름)_ 거리가 `dist`인 위치 **4개**가 먼저 큐에 들어가고, 그 중 첫 번째로 뽑힌 위치에 의해 거리가 `dist+1`인 위치 **4개**가 또 다시 큐에 들어갈 것이다.  
      이때, 큐에는 `거리가 (dist)인 위치 3개 + 거리가 (dist+1)인 위치 4개`가 존재하게 된다.
    - 즉, **큐에는 항상 동일한 거리의 위치만 존재하는 것이 아니다.**

- **[수정한 코드]** 따라서 본래 의도대로 코드를 짜려면 아래와 같이 조건을 추가해야 한다.

  ```cpp
  if (road[row][col] >= 2) {
      while (!q.empty() && dist[q.front().first][q.front().second] == dist[row][col]) { // 거리 조건 추가
          if (road[q.front().first][q.front().second] >= 2) {
              coord.push_back({road[q.front().first][q.front().second], q.front().first, q.front().second});
          }
          q.pop();
      }
      // ... 생략 ...
  }
  ```

## 개선된 점

- 뼈대 코드를 미리 설계하고 코드를 작성하다보니, 로직 설계와 관련된 오류는 없었던 것 같다.

## 아쉬운 점

- `BFS` 동작 흐름에 대한 오개념 _(이전에도 비슷하게 틀렸던 적이 있었던 것 같은데, 오개념이 머리에 박혀버렸던 것 같다.)_
  - BFS의 핵심은 **"가까운 거리를 먼저 방문할 수 있다"** 는 점
  - BFS의 큐에는 **항상 같은 거리의 위치만 존재하는 것이 아니다!**
