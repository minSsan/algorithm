## 문제 정보

> 삼성 SW 역량 테스트 - 2020년 상반기 오후 1번  
> [백준 20061번](https://www.acmicpc.net/problem/20061)
> 시뮬레이션, 구현

## 실수했던 부분

- 문제 이해 부족

  1. `연한 영역 이동` | `진한 영역 이동`이 서로 독립적으로 이뤄지는 것으로 잘못 이해함  
     👉🏻 **이에 대한 언급은 문제 설명 그 어디에도 없음.** 즉, 행/열이 삭제될 때마다 연한 영역에 있는 행/열도 같이 이동하는 것이 당연하다.
     <br/>

  2. 행/열 이동시키는 과정에서 **보드 상태가 계속해서 변화함**  
     👉🏻 처음 상태 값 _(= 모두 채워진 행/열 번호 | 0, 1번 행에 블록이 있는 상태)_ 이 유지되지 않기 때문에, 행/열이 이동할 때마다 다시 확인해야 함

<br/>

### 가장 실수가 잦았던 부분

`보드의 블록 상태를 문제 조건에 맞게 변형하는 함수`

```cpp
// 파란 보드의 블록 이동이 모두 끝난 후, 조건에 맞게 보드 칸을 이동시키는 함수
void move_right(vector<int> col_arr) { // col_arr - 가장 최근 들어온 블록들의 최종 위치 column 값들
    vector<int> filled_col;
    set<int> special_col;

    //* 1. 가득 찬 타일 + 0, 1 열 타일 존재 조건 모두 만족하는지 확인
    for (int col : col_arr) {
        if (col == 0 || col == 1) special_col.insert(col);

        int cnt = 0;
        for (int row = 0; row < 4; ++row) {
            if (blue_board[row][col]) ++cnt;
        }
        if (cnt == 4) filled_col.push_back(col);
    }

    //* 2. 두 조건 중 하나라도 성립하는 경우
    if (filled_col.size() > 0 || special_col.size() > 0) {
        //* 1. 가득 찬 열을 먼저 이동시킨다. (두 조건이 모두 성립할 경우 이를 먼저 실행해야 함)
        for (int col : filled_col) {
            move_right_vivid(col);
            ++score;
        }

        //* 2. 블록이 포함 된 연한 열의 개수만큼 이동시킨다.
        for (int i = 0; i < special_col.size(); ++i) {
            move_right_all();
        }
    }
}
```

> ### ✍🏻 문제점 회고
>
> 1. `col_arr` 사용으로 괜히 코드가 더 복잡해짐 👉🏻 <U>**시간초과 아닌 이상, 구현이 더 편한 방법(여기서는 중첩 for문) 사용**</U>하자.
>
> 2. 블록이 가득 찬 행/열이 여러 개 존재할 수 있다. 즉, **행/열이 삭제되는 과정에서 `filled_col` 값이 계속해서 바뀜** 👉🏻 정렬을 사용하면 되겠지만.. 굳이?  
>    얘도 마찬가지로 행/열을 삭제할 때마다 다음에 삭제할 행/열을 전수조사로 다시 찾는 것이 <U>**더 간편하다**</U>.

## 비슷한 유형 문제에서 주의해야 할 부분

- 시간 초과가 아닌 이상, 구현이 더 쉬운 방법을 택하자.
- 문제를 정확히 이해하자.

## 전체 리뷰

- 🌟 시간 복잡도에 문제되지 않으면, 더 쉬운 방법으로 구현하자.
  - 이번 문제에서, 탐색 수 최대한 줄이려 `블록이 새로 들어선 지점의 행/열`만 검사하려다가 괜히 더 복잡해져서 실수 ⬆
    - 중첩 for문 돌려서 모두 탐색하면 간단하게 해결할 수 있었음 _(보드 크기가 `6 X 4`여서 복잡도가 크지 않았음)_
      <br/>
- 🌟 검사 과정에서 배열 상태 변경에 유의하자
  - ❗️ <U>**이전 값의 변경이 다음 검사 과정에 영향이 가는지**</U>, 최우선으로 고려한다.
  - 배열이 계속 업데이트 되기 때문에, `처음 상태 값을 그대로 사용할 수 없음`
    - 위 경우와 마찬가지로, **한번 업데이트 하고 나면 중첩 for문으로 전수 조사 필요**했음
