## 문제 정보

> 삼성 SW 역량 테스트 - 2021년 하반기 오후 2번  
> [백준 23291번](https://www.acmicpc.net/problem/23291)  
> 시뮬레이션, 구현

## 구현 과정

- 문제 필기 + 로직 설계 (약 1시간 30분)
- 코드 작성 (약 2시간)
- 문제점 해결 (약 20분)

## 문제가 된 부분

- 인접한 물고기 수를 검사하는 과정 (`BFS`)

  - **문제에서 요구한 것**  
    인접한 한 쌍의 어항은 딱 한번만 검사한다.

  - **실수했던 부분**  
    동/서/남/북 방향 모두 검사 + 방문 처리를 바로 했음

    - 우선, 방문처리를 곧바로 하게 되면 **이후에 등장하는 인접 위치는 해당 어항을 검사하지 못한다**. _(ex. `{0,1}`에서 `{1,1}` 방문처리 -> ... -> `{1,0}`에서 `{1,1}` 위치를 탐색 해야하나 이미 방문처리 되어서 탐색 불가능)_

  - **해결방법**  
    동/서/남/북 방향 모두 검사 + 방문 여부는 **queue에서 `pop` 되는 시점에 기록**. _❗️단, 이미 방문한 노드일 경우 탐색을 진행하지 않음_  
     👉🏻 즉, visited 값은 **해당 위치에서 동/서/남/북 탐색을 끝냈는지 여부**를 의미
  - **⭐️ 더 좋은 해결방법**  
    `동/남` 방향만 검사
    - 인접하는 쌍은 단 한번만 검사해야 하기 때문에, **탐색 방향**을 `동/남` **두 가지 방향으로만** 정하면 이미 탐색한 쌍에 대해서는 중복검사하지 않는다. _(우측, 하향으로 계속 검사하는 것과 동일)_

## 개선된 점

- 코드 설계 정확성
  - 코드 설계를 미리 완료한 후에 구현을 하다보니, 로직 자체에는 오류가 없었음.

## 아쉬운 점

- 앞서 언급한 BFS 탐색 과정에서의 실수
- 물고기 수가 최소인 어항을 찾을 때, **첫 번째 어항의 값을 최소값 배열에 추가하지 않음**
- 풀이 방식이 복잡해서 실수할 여지가 높았음
  - 벡터 대신 `deque<int>` 타입의 배열로 구현했으면 풀이가 더 간단했을 것 같다.
