## BFS, 구현

- 구현 문제와 연계 되어 출제되는 `BFS/DFS` 문제의 경우, `BFS/DFS`의 로직 및 실행 흐름을 정확히 이해하여 **조건사항을 빠짐없이 구현하도록** 주의한다.

## 정리노트

- [이번 문제](https://www.acmicpc.net/problem/2573)는 한 주기마다
  BFS를 실행하는 문제였다.

  - 구현한 bfs 함수를 반복 호출하는 방식도 있지만, **너비 탐색의 경우 한 주기마다 서로 동일한 거리 값(= 이 문제에서는 year 값)을 가지므로**, 이 특성을 이용하여 bfs를 반복 호출하는 방식은 사용하지 않았다. 그 대신 _조건문으로 이전 거리 값과 현재 거리 값이 동일한지 확인하여, 주기가 변했는지 확인_ 하는 과정을 거쳤다.

- 문제에서 놓쳤던 부분은 "**얼음이 동시에 녹는다는 점**"이다. 문제에 명확히 설명되지 않은 부분이지만, 문제에 나온 예제를 통해 이를 충분히 유추할 수 있다.

  - 이를 고려하지 않고 구현하게 되면, 동일한 주기 내에서 먼저 녹은 얼음에 영향을 받는다.
  - 따라서 각 주기에 대해 탐색을 진행하기 전, `초기 상태의 물 위치`를 기록해두어야 하고 **빙산의 높이를 계산하는 과정**에서도 해당 기록을 사용해야 한다.
  - 이를 파악한 후, 아래와 같이 함수를 추가하고 각 주기마다 `mark_water` 함수를 호출하였다.

  ```cpp
    /**
    * 입력받은 위치가 물의 영역인지 검사하는 함수
    */
    bool is_water(short row, short col) {
        return (0 <= row && row < n) && (0 <= col && col < m) && (water[row][col]);
    }

    /**
    * 물이 존재하는 영역을 표시하는 함수
    */
    void mark_water() {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                water[i][j] = graph[i][j] == 0;
            }
        }
    }
  ```
